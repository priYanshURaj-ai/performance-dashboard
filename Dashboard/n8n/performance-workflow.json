{
    "name": "Performance Dashboard - Enhanced Multi-Board",
    "nodes": [
        {
            "parameters": {
                "content": "## üìä Performance Dashboard Workflow v2.0\n\n### Key Updates\n- **Multi-Board Support**: Dynamic board selection\n- **6 hrs/day bandwidth**: 30 hrs/week\n- **Task-based Available Bandwidth**: % tasks completed\n- **Subtask Worklog Tracking**: Tracks all contributors\n- **GitHub Gist Storage**: Unlimited size, free!\n\n### Flow\n```\nDaily 9:30 PM IST\n    ‚Üì\nFetch JIRA Issues (all including subtasks)\n    ‚Üì\nProcess & Calculate Metrics\n    ‚Üì\nSave to GitHub Gist\n```\n\n### Bandwidth Logic\n- **Highest Utilization**: Hours logged / Expected hours\n- **Most Available**: % tasks COMPLETED (done/total)\n- **Individual**: Est hours (Done) vs Logged hours"
            },
            "id": "workflow-doc",
            "name": "üìã Documentation v2",
            "type": "n8n-nodes-base.stickyNote",
            "typeVersion": 1,
            "position": [-200, 200]
        },
        {
            "parameters": {
                "rule": {
                    "interval": [{ "field": "cronExpression", "expression": "0 16 * * *" }]
                }
            },
            "id": "daily-trigger",
            "name": "Daily 9:30 PM IST",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [100, 400],
            "notes": "9:30 PM IST = 4:00 PM UTC (16:00)"
        },
        {
            "parameters": {},
            "id": "manual-trigger",
            "name": "Manual Trigger",
            "type": "n8n-nodes-base.manualTrigger",
            "typeVersion": 1,
            "position": [100, 600]
        },
        {
            "parameters": {
                "jsCode": "// ========================================\n// CONFIGURATION - ENHANCED MULTI-BOARD v2.0\n// ========================================\n\n// Available Boards/Components for dropdown - ALL PAI BOARDS\nconst AVAILABLE_BOARDS = [\n  { id: 'all-pai', name: 'üìä All PAI Projects', components: [], project: 'PAI', matchAll: true },\n  { id: 'bot-engine', name: 'Bot Engine', components: ['Bot Engine'], project: 'PAI' },\n  { id: 're-platform', name: 'RE Platform 2.0', components: ['RE Platform 2.0'], project: 'PAI' },\n  { id: 'pi-re-2', name: 'Pi RE 2.0', components: ['Pi RE 2.0'], project: 'PAI' },\n  { id: 'agentic-interaction', name: 'Agentic Interaction Hub', components: ['Agentic Interaction Hub'], project: 'PAI' },\n  { id: 'agentic-quality', name: 'Agentic Quality Hub', components: ['Agentic Quality Hub'], project: 'PAI' },\n  { id: 'analytics', name: 'Analytics', components: ['Analytics'], project: 'PAI' },\n  { id: 'application', name: 'Application', components: ['Application'], project: 'PAI' },\n  { id: 'feature-hub-india', name: 'Feature Hub India', components: ['Feature Hub India'], project: 'PAI' },\n  { id: 'feature-store', name: 'Pi Feature Store', components: ['Pi Feature Store', 'Feature Store'], project: 'PAI' },\n  { id: 'feature-store-caretaker', name: 'Feature Store - Caretaker', components: ['Feature Store - Caretaker'], project: 'PAI' },\n  { id: 'feature-store-realtime', name: 'Feature Store - Real Time', components: ['Feature Store - Real Time'], project: 'PAI' },\n  { id: 'fe-kanban', name: 'FE Kanban', components: ['FE Kanban'], project: 'PAI' },\n  { id: 'lending-risk-policy', name: 'Lending Risk Policy', components: ['Lending Risk Policy'], project: 'PAI' },\n  { id: 'migration-tasks', name: 'Migration Tasks', components: ['Migration Tasks'], project: 'PAI' },\n  { id: 'ml-lending-ds', name: 'ML Lending Data Science', components: ['ML Lending Data Science'], project: 'PAI' },\n  { id: 'mlops', name: 'MLOPS', components: ['MLOPS'], project: 'PAI' },\n  { id: 'mlops-scrum', name: 'MLOPS Scrum', components: ['MLOPS Scrum'], project: 'PAI' },\n  { id: 'pai-board', name: 'PAI Board', components: ['PAI Board'], project: 'PAI' },\n  { id: 'pi-ai', name: 'Pi AI', components: ['Pi AI'], project: 'PAI' },\n  { id: 'pi-anomaly', name: 'Pi Anomaly Detection & Verifier', components: ['Pi Anomaly Detection & Verifier'], project: 'PAI' },\n  { id: 'pi-application', name: 'Pi Application', components: ['Pi Application'], project: 'PAI' },\n  { id: 'pi-case-mgmt', name: 'Pi Case Management', components: ['Pi Case Management'], project: 'PAI' },\n  { id: 'pi-data-ingestion', name: 'Pi Data Ingestion & Validation', components: ['Pi Data Ingestion & Validation'], project: 'PAI' },\n  { id: 'pi-data-science', name: 'Pi Data Science', components: ['Pi Data Science'], project: 'PAI' },\n  { id: 'pi-dev-maturity', name: 'Pi Dev Maturity', components: ['Pi Dev Maturity'], project: 'PAI' },\n  { id: 'pi-devops', name: 'Pi DevOps', components: ['Pi DevOps'], project: 'PAI' },\n  { id: 'pi-devops-interrupt', name: 'Pi DevOps Interrupt', components: ['Pi DevOps Interrupt'], project: 'PAI' },\n  { id: 'pi-dwh', name: 'Pi DWH', components: ['Pi DWH'], project: 'PAI' },\n  { id: 'pi-fe', name: 'PI FE', components: ['PI FE'], project: 'PAI' },\n  { id: 'pi-frontend', name: 'Pi Frontend', components: ['Pi Frontend'], project: 'PAI' },\n  { id: 'pi-jobmanager', name: 'Pi JobManager', components: ['Pi JobManager'], project: 'PAI' },\n  { id: 'pi-lending-analytics', name: 'Pi Lending Analytics', components: ['Pi Lending Analytics'], project: 'PAI' },\n  { id: 'pi-ml', name: 'Pi ML', components: ['Pi ML'], project: 'PAI' },\n  { id: 'pi-ml-serving', name: 'Pi ML Serving', components: ['Pi ML Serving'], project: 'PAI' },\n  { id: 'pi-platform-aquifer', name: 'Pi Platform Devs - Team Aquifer', components: ['Pi Platform Devs - Team Aquifer'], project: 'PAI' },\n  { id: 'pi-platform-zephyr', name: 'Pi Platform Devs - Team Zephyr', components: ['Pi Platform Devs - Team Zephyr'], project: 'PAI' },\n  { id: 'pi-product-analytics', name: 'Pi Product Analytics', components: ['Pi Product Analytics'], project: 'PAI' },\n  { id: 'pi-product-fraud', name: 'Pi Product Team + Fraud Risk Control', components: ['Pi Product Team + Fraud Risk Control'], project: 'PAI' },\n  { id: 'pi-risk-control', name: 'Pi Risk Control', components: ['Pi Risk Control'], project: 'PAI' },\n  { id: 'pi-risk-rule-engine', name: 'Pi Risk Rule Engine Board', components: ['Pi Risk Rule Engine Board'], project: 'PAI' },\n  { id: 'pi-solution-expert', name: 'Pi - Solution Expert Team', components: ['Pi - Solution Expert Team'], project: 'PAI' },\n  { id: 'pml-bugs', name: 'PML Bugs', components: ['PML Bugs'], project: 'PAI' },\n  { id: 'ppsl-mhd', name: 'PPSL MHD (Online Merchants)', components: ['PPSL MHD'], project: 'PAI' },\n  { id: 'risk-analytics', name: 'Risk Analytics', components: ['Risk Analytics'], project: 'PAI' },\n  { id: 'risk-product', name: 'Risk Product Initiatives', components: ['Risk Product Initiatives'], project: 'PAI' },\n  { id: 'tech-debts', name: 'Tech Debts', components: ['Tech debts', 'Tech Debt Scrum'], project: 'PAI' },\n  { id: 'templatization', name: 'Templatization', components: ['Templatization'], project: 'PAI' },\n  { id: 'truefoundry', name: 'Truefoundry Migration', components: ['Truefoundry Migration'], project: 'PAI' }\n];\n\n// Default selected board (will be overridden by frontend)\nconst DEFAULT_BOARD_ID = 'all-pai';\n\n// NEW: 6 hours per day (as per requirement)\nconst HOURS_PER_DAY = 6;\nconst WORKING_DAYS_PER_WEEK = 5;\nconst HOURS_PER_WEEK = HOURS_PER_DAY * WORKING_DAYS_PER_WEEK; // 30 hours\n\n// ========================================\n\n// Team members will be dynamically extracted from JIRA assignees\nconst teamMembers = [];\n\nconst today = new Date();\nconst formatDate = (d) => d.toISOString().split('T')[0];\nconst getDateDaysAgo = (days) => { const d = new Date(today); d.setDate(d.getDate() - days); return formatDate(d); };\n\n// Sprint calculation (bi-weekly sprints)\nconst getNthMondayOfMonth = (year, month, n) => {\n  const firstDay = new Date(year, month, 1);\n  const dayOfWeek = firstDay.getDay();\n  const firstMonday = dayOfWeek <= 1 ? 1 + (1 - dayOfWeek) : 1 + (8 - dayOfWeek);\n  return new Date(year, month, firstMonday + (n - 1) * 7);\n};\n\nconst getSprintDates = (ref) => {\n  const year = ref.getFullYear(), month = ref.getMonth();\n  const firstMonday = getNthMondayOfMonth(year, month, 1);\n  const thirdMonday = getNthMondayOfMonth(year, month, 3);\n  const nextMonth = month === 11 ? 0 : month + 1;\n  const nextYear = month === 11 ? year + 1 : year;\n  const nextFirstMonday = getNthMondayOfMonth(nextYear, nextMonth, 1);\n  \n  let current, previous;\n  if (ref >= thirdMonday) {\n    current = { name: 'Sprint 2', number: 2, startDate: thirdMonday, endDate: new Date(nextFirstMonday.getTime() - 1), month: ref.toLocaleString('en-US', { month: 'short' }), year };\n    previous = { name: 'Sprint 1', number: 1, startDate: firstMonday, endDate: new Date(thirdMonday.getTime() - 1), month: ref.toLocaleString('en-US', { month: 'short' }), year };\n  } else if (ref >= firstMonday) {\n    current = { name: 'Sprint 1', number: 1, startDate: firstMonday, endDate: new Date(thirdMonday.getTime() - 1), month: ref.toLocaleString('en-US', { month: 'short' }), year };\n    const pm = month === 0 ? 11 : month - 1, py = month === 0 ? year - 1 : year;\n    previous = { name: 'Sprint 2', number: 2, startDate: getNthMondayOfMonth(py, pm, 3), endDate: new Date(firstMonday.getTime() - 1), month: new Date(py, pm).toLocaleString('en-US', { month: 'short' }), year: py };\n  } else {\n    const pm = month === 0 ? 11 : month - 1, py = month === 0 ? year - 1 : year;\n    current = { name: 'Sprint 2', number: 2, startDate: getNthMondayOfMonth(py, pm, 3), endDate: new Date(firstMonday.getTime() - 1), month: new Date(py, pm).toLocaleString('en-US', { month: 'short' }), year: py };\n    previous = { name: 'Sprint 1', number: 1, startDate: getNthMondayOfMonth(py, pm, 1), endDate: new Date(getNthMondayOfMonth(py, pm, 3).getTime() - 1), month: new Date(py, pm).toLocaleString('en-US', { month: 'short' }), year: py };\n  }\n  \n  const countWorkingDays = (s, e) => { let c = 0; const cur = new Date(s); while (cur <= e) { if (cur.getDay() !== 0 && cur.getDay() !== 6) c++; cur.setDate(cur.getDate() + 1); } return c; };\n  \n  // Use 6 hours per day\n  current.workingDays = countWorkingDays(current.startDate, current.endDate);\n  current.totalHours = current.workingDays * HOURS_PER_DAY;\n  const todayEnd = new Date(ref); todayEnd.setHours(23, 59, 59, 999);\n  current.elapsedWorkingDays = countWorkingDays(current.startDate, todayEnd);\n  current.elapsedHours = current.elapsedWorkingDays * HOURS_PER_DAY;\n  current.sprintDay = current.elapsedWorkingDays;\n  current.label = `${current.month} ${current.name}`;\n  current.dateRange = `${formatDate(current.startDate)} to ${formatDate(current.endDate)}`;\n  \n  previous.workingDays = countWorkingDays(previous.startDate, previous.endDate);\n  previous.totalHours = previous.workingDays * HOURS_PER_DAY;\n  previous.elapsedWorkingDays = previous.workingDays;\n  previous.elapsedHours = previous.totalHours;\n  previous.sprintDay = previous.workingDays;\n  previous.label = `${previous.month} ${previous.name}`;\n  previous.dateRange = `${formatDate(previous.startDate)} to ${formatDate(previous.endDate)}`;\n  \n  return { current, previous };\n};\n\nconst sprints = getSprintDates(today);\n\n// Working hours for periods (6 hrs/day)\nconst workingHours = {\n  '7days': HOURS_PER_DAY * 5,    // 30 hours (1 week)\n  '15days': HOURS_PER_DAY * 11,  // 66 hours (~2 weeks)\n  '30days': HOURS_PER_DAY * 22   // 132 hours (~1 month)\n};\n\nconst periods = {\n  '7days': { start: getDateDaysAgo(7), end: formatDate(today), label: 'Last 7 Days' },\n  '15days': { start: getDateDaysAgo(15), end: formatDate(today), label: 'Last 15 Days' },\n  '30days': { start: getDateDaysAgo(30), end: formatDate(today), label: 'Last 30 Days' }\n};\n\nreturn [{ \n  json: { \n    availableBoards: AVAILABLE_BOARDS,\n    defaultBoardId: DEFAULT_BOARD_ID,\n    hoursPerDay: HOURS_PER_DAY,\n    hoursPerWeek: HOURS_PER_WEEK,\n    teamMembers, \n    periods, \n    workingHours,\n    sprints: { \n      current: { ...sprints.current, startDate: formatDate(sprints.current.startDate), endDate: formatDate(sprints.current.endDate) }, \n      previous: { ...sprints.previous, startDate: formatDate(sprints.previous.startDate), endDate: formatDate(sprints.previous.endDate) } \n    }, \n    today: formatDate(today), \n    timestamp: today.toISOString() \n  } \n}];"
            },
            "id": "config-setup",
            "name": "‚öôÔ∏è Setup Config v2",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [350, 500]
        },
        {
            "parameters": {
                "operation": "getAll",
                "returnAll": true,
                "options": {
                    "fieldsByKey": false,
                    "jql": "project = PAI AND updated >= -30d ORDER BY updated DESC",
                    "expand": "changelog"
                }
            },
            "id": "jira-all",
            "name": "üì• JIRA - All Issues",
            "type": "n8n-nodes-base.jira",
            "typeVersion": 1,
            "position": [600, 500],
            "alwaysOutputData": true,
            "credentials": {
                "jiraSoftwareCloudApi": {
                    "id": "GFoi8KotNCCPvlLK",
                    "name": "Jira SW Cloud account 7"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// ================================================================\n// ENHANCED PROCESSING v2.0\n// - Multi-board support\n// - Task-based bandwidth (Most Available = % open tasks)\n// - Subtask worklog tracking\n// - Est hours vs Logged for Done tickets\n// ================================================================\n\nconst configData = $('‚öôÔ∏è Setup Config v2').first().json;\nconst { teamMembers, availableBoards, defaultBoardId, hoursPerDay, hoursPerWeek, sprints, workingHours } = configData;\n\n// Get all issues from JIRA\nconst allJiraIssues = $('üì• JIRA - All Issues').all().map(i => i.json);\n\nconsole.log(`üìä Total issues fetched: ${allJiraIssues.length}`);\n\n// Separate parent issues and subtasks\nconst parentIssues = allJiraIssues.filter(i => !i.fields?.parent);\nconst subtasks = allJiraIssues.filter(i => i.fields?.parent);\n\nconsole.log(`üìä Parent issues: ${parentIssues.length}`);\nconsole.log(`üìä Subtasks: ${subtasks.length}`);\n\nconst now = new Date();\nconst cutoff7d = new Date(now); cutoff7d.setDate(now.getDate() - 7);\nconst cutoff15d = new Date(now); cutoff15d.setDate(now.getDate() - 15);\n\nconst currentSprintStart = new Date(sprints.current.startDate);\nconst currentSprintEnd = new Date(sprints.current.endDate); currentSprintEnd.setHours(23,59,59,999);\nconst prevSprintStart = new Date(sprints.previous.startDate);\nconst prevSprintEnd = new Date(sprints.previous.endDate); prevSprintEnd.setHours(23,59,59,999);\n\n// Status mapping\nconst statusMap = {\n  'To Do': 'toDo', 'TO DO': 'toDo', 'Open': 'toDo', 'Backlog': 'toDo', 'New': 'toDo',\n  'In Progress': 'inProgress', 'IN PROGRESS': 'inProgress', 'In Review': 'inProgress', 'Code Review': 'inProgress', 'In Development': 'inProgress',\n  'UAT': 'uat', 'QA': 'uat', 'Testing': 'uat', 'Ready for UAT': 'uat',\n  'Done': 'done', 'DONE': 'done', 'Closed': 'done', 'Resolved': 'done', 'Complete': 'done', 'Completed': 'done'\n};\nconst getStatus = (s) => statusMap[s] || 'toDo';\nconst isDoneStatus = (s) => getStatus(s) === 'done';\n\n// Email matching helper\nconst matchesEmail = (emailAddress, targetEmail) => {\n  if (!emailAddress || !targetEmail) return false;\n  const el = targetEmail.toLowerCase();\n  const ep = el.split('@')[0];\n  const ae = (emailAddress || '').toLowerCase();\n  if (ae === el || ae.includes(ep)) return true;\n  return false;\n};\n\nconst matchesByName = (displayName, targetEmail) => {\n  if (!displayName || !targetEmail) return false;\n  const ep = targetEmail.toLowerCase().split('@')[0];\n  const dn = (displayName || '').toLowerCase();\n  const parts = ep.replace(/[0-9]/g, '').replace(/\\./g, ' ').split(' ').filter(p => p.length > 2);\n  return parts.length > 0 && parts.every(p => dn.includes(p));\n};\n\nconst isAssignee = (issue, email) => {\n  const a = issue.fields?.assignee;\n  if (!a) return false;\n  return matchesEmail(a.emailAddress, email) || matchesByName(a.displayName, email);\n};\n\n// ================================================================\n// Extract worklogs from issue (including subtasks)\n// Tracks who logged time and when\n// ================================================================\nconst extractWorklogs = (issue) => {\n  const worklogs = issue.fields?.worklog?.worklogs || [];\n  return worklogs.map(wl => ({\n    author: wl.author?.emailAddress || wl.author?.displayName || 'Unknown',\n    authorName: wl.author?.displayName || 'Unknown',\n    timeSpentSeconds: wl.timeSpentSeconds || 0,\n    started: wl.started,\n    issueKey: issue.key,\n    issueSummary: issue.fields?.summary || '',\n    parentKey: issue.fields?.parent?.key || null,\n    isSubtask: !!issue.fields?.parent\n  }));\n};\n\n// Process data for each board configuration\nconst processForBoard = (boardConfig) => {\n  const { id: boardId, name: boardName, components, project, matchAll } = boardConfig;\n  \n  // Filter issues by board components (or get all if matchAll is true)\n  const boardIssues = matchAll ? allJiraIssues : allJiraIssues.filter(issue => {\n    const comps = issue.fields?.components || [];\n    return comps.some(c => components.includes(c.name));\n  });\n  \n  console.log(`üìä Board ${boardName}: ${boardIssues.length} issues`);\n  \n  // Filter functions\n  const filterByPeriod = (issues, cutoff) => issues.filter(i => new Date(i.fields?.updated || i.fields?.created) >= cutoff);\n  const filterBySprint = (issues, start, end) => issues.filter(i => { const d = new Date(i.fields?.created); return d >= start && d <= end; });\n  \n  const issues7d = filterByPeriod(boardIssues, cutoff7d);\n  const issues15d = filterByPeriod(boardIssues, cutoff15d);\n  const issues30d = boardIssues;\n  const issuesCurrent = filterBySprint(boardIssues, currentSprintStart, currentSprintEnd);\n  const issuesPrev = filterBySprint(boardIssues, prevSprintStart, prevSprintEnd);\n  \n  // ================================================================\n  // Collect all worklogs for the sprint period\n  // ================================================================\n  const allWorklogs = [];\n  boardIssues.forEach(issue => {\n    const wls = extractWorklogs(issue);\n    allWorklogs.push(...wls);\n  });\n  \n  // Filter worklogs by sprint dates\n  const filterWorklogsBySprint = (worklogs, start, end) => {\n    return worklogs.filter(wl => {\n      const wlDate = new Date(wl.started);\n      return wlDate >= start && wlDate <= end;\n    });\n  };\n  \n  const currentSprintWorklogs = filterWorklogsBySprint(allWorklogs, currentSprintStart, currentSprintEnd);\n  const prevSprintWorklogs = filterWorklogsBySprint(allWorklogs, prevSprintStart, prevSprintEnd);\n  \n  // ================================================================\n  // Calculate metrics for a member\n  // ================================================================\n  const getMetrics = (issues, email) => {\n    const memberIssues = issues.filter(i => isAssignee(i, email));\n    const counts = { total: memberIssues.length, done: 0, inProgress: 0, uat: 0, toDo: 0 };\n    let logged = 0, estimated = 0, estimatedDone = 0, loggedDone = 0;\n    \n    memberIssues.forEach(i => {\n      const status = getStatus(i.fields?.status?.name || 'To Do');\n      counts[status]++;\n      \n      const spent = (i.fields?.timespent || 0) / 3600;\n      const est = (i.fields?.timeoriginalestimate || 0) / 3600;\n      logged += spent;\n      estimated += est;\n      \n      // Track Done tickets separately for bandwidth calc\n      if (status === 'done') {\n        estimatedDone += est;\n        loggedDone += spent;\n      }\n    });\n    \n    const topIssues = memberIssues.filter(i => (i.fields?.timespent || 0) > 0)\n      .sort((a,b) => (b.fields?.timespent || 0) - (a.fields?.timespent || 0))\n      .slice(0,4)\n      .map(i => ({ \n        key: i.key, \n        summary: i.fields?.summary || '',\n        status: getStatus(i.fields?.status?.name || 'To Do'),\n        statusName: i.fields?.status?.name || 'To Do',\n        hours: Math.round((i.fields?.timespent || 0) / 3600 * 10) / 10,\n        estimated: Math.round((i.fields?.timeoriginalestimate || 0) / 3600 * 10) / 10\n      }));\n    \n    return { \n      ...counts, \n      hoursLogged: Math.round(logged * 10) / 10, \n      estimatedHours: Math.round(estimated * 10) / 10,\n      estimatedDone: Math.round(estimatedDone * 10) / 10,\n      loggedDone: Math.round(loggedDone * 10) / 10,\n      topIssues \n    };\n  };\n  \n  // ================================================================\n  // Sprint metrics with task-based bandwidth\n  // ================================================================\n  const getSprintMetrics = (issues, email, sprintInfo, sprintWorklogs) => {\n    const memberIssues = issues.filter(i => isAssignee(i, email));\n    const counts = { total: memberIssues.length, done: 0, inProgress: 0, uat: 0, toDo: 0 };\n    let logged = 0, estimated = 0, estimatedDone = 0, loggedDone = 0;\n    \n    memberIssues.forEach(i => {\n      const status = getStatus(i.fields?.status?.name || 'To Do');\n      counts[status]++;\n      \n      const spent = (i.fields?.timespent || 0) / 3600;\n      const est = (i.fields?.timeoriginalestimate || 0) / 3600;\n      logged += spent;\n      estimated += est;\n      \n      if (status === 'done') {\n        estimatedDone += est;\n        loggedDone += spent;\n      }\n    });\n    \n    // ================================================================\n    // Add worklog hours from subtasks where user logged time\n    // ================================================================\n    const memberWorklogs = sprintWorklogs.filter(wl => \n      matchesEmail(wl.author, email) || matchesByName(wl.authorName, email)\n    );\n    \n    const worklogHours = memberWorklogs.reduce((sum, wl) => sum + (wl.timeSpentSeconds / 3600), 0);\n    \n    // Get unique worklog issues\n    const worklogIssues = [...new Set(memberWorklogs.map(wl => wl.issueKey))];\n    \n    // ================================================================\n    // Task-based bandwidth calculations\n    // ================================================================\n    const openTasks = counts.total - counts.done;\n    const taskCompletionPercent = counts.total > 0 ? (counts.done / counts.total) * 100 : 0;\n    const taskRemainingPercent = 100 - taskCompletionPercent; // \"bandwidth free\" from tasks\n    \n    // Individual bandwidth: Est hours on Done vs Logged on Done\n    const bandwidthEfficiency = estimatedDone > 0 ? (loggedDone / estimatedDone) * 100 : 0;\n    \n    const topIssues = memberIssues.filter(i => (i.fields?.timespent || 0) > 0)\n      .sort((a,b) => (b.fields?.timespent || 0) - (a.fields?.timespent || 0))\n      .slice(0,4)\n      .map(i => ({ \n        key: i.key, \n        summary: i.fields?.summary || '',\n        status: getStatus(i.fields?.status?.name || 'To Do'),\n        statusName: i.fields?.status?.name || 'To Do',\n        hours: Math.round((i.fields?.timespent || 0) / 3600 * 10) / 10,\n        estimated: Math.round((i.fields?.timeoriginalestimate || 0) / 3600 * 10) / 10\n      }));\n    \n    const allIssues = memberIssues.map(i => ({ \n      key: i.key, \n      summary: i.fields?.summary || '',\n      status: getStatus(i.fields?.status?.name || 'To Do'),\n      statusName: i.fields?.status?.name || 'To Do',\n      hours: Math.round((i.fields?.timespent || 0) / 3600 * 10) / 10,\n      estimated: Math.round((i.fields?.timeoriginalestimate || 0) / 3600 * 10) / 10\n    }));\n    \n    return { \n      ...counts,\n      openTasks,\n      hoursLogged: Math.round(logged * 10) / 10, \n      estimatedHours: Math.round(estimated * 10) / 10,\n      estimatedDone: Math.round(estimatedDone * 10) / 10,\n      loggedDone: Math.round(loggedDone * 10) / 10,\n      // Worklog-based hours (from subtasks)\n      worklogHours: Math.round(worklogHours * 10) / 10,\n      worklogIssueCount: worklogIssues.length,\n      // Task-based bandwidth\n      taskCompletionPercent: Math.round(taskCompletionPercent * 10) / 10,\n      taskRemainingPercent: Math.round(taskRemainingPercent * 10) / 10,\n      // Efficiency (logged vs estimated on Done)\n      bandwidthEfficiency: Math.round(bandwidthEfficiency * 10) / 10,\n      totalHours: sprintInfo.totalHours, \n      workingDays: sprintInfo.workingDays, \n      topIssues, \n      allIssues \n    };\n  };\n  \n  // Team summary\n  const teamSummary = (issues) => {\n    const s = { total: issues.length, done: 0, inProgress: 0, uat: 0, toDo: 0, totalHoursLogged: 0, totalEstimatedHours: 0 };\n    issues.forEach(i => { \n      s[getStatus(i.fields?.status?.name || 'To Do')]++; \n      s.totalHoursLogged += (i.fields?.timespent || 0) / 3600; \n      s.totalEstimatedHours += (i.fields?.timeoriginalestimate || 0) / 3600; \n    });\n    s.totalHoursLogged = Math.round(s.totalHoursLogged * 10) / 10;\n    s.totalEstimatedHours = Math.round(s.totalEstimatedHours * 10) / 10;\n    return s;\n  };\n  \n  // Build member data\n  const members = teamMembers.map(m => ({\n    name: m.name, \n    email: m.email, \n    avatar: m.avatar,\n    metrics: { \n      '7days': getMetrics(issues7d, m.email), \n      '15days': getMetrics(issues15d, m.email), \n      '30days': getMetrics(issues30d, m.email) \n    },\n    sprintMetrics: { \n      current: getSprintMetrics(issuesCurrent, m.email, sprints.current, currentSprintWorklogs), \n      previous: getSprintMetrics(issuesPrev, m.email, sprints.previous, prevSprintWorklogs) \n    }\n  }));\n  \n  return {\n    boardId,\n    boardName,\n    components,\n    project,\n    teamSummary: {\n      '7days': teamSummary(issues7d), \n      '15days': teamSummary(issues15d), \n      '30days': teamSummary(issues30d),\n      'currentSprint': teamSummary(issuesCurrent), \n      'previousSprint': teamSummary(issuesPrev)\n    },\n    members\n  };\n};\n\n// Process all boards\nconst boardsData = {};\navailableBoards.forEach(board => {\n  boardsData[board.id] = processForBoard(board);\n});\n\n// Build final output\nconst output = {\n  lastUpdated: new Date().toISOString(),\n  generatedAt: configData.timestamp,\n  version: '2.0',\n  \n  // Board configuration\n  availableBoards: availableBoards,\n  defaultBoardId: defaultBoardId,\n  selectedBoardId: defaultBoardId, // Can be changed by frontend\n  \n  // Time configuration\n  hoursPerDay,\n  hoursPerWeek,\n  workingHours: configData.workingHours,\n  \n  // Sprint info\n  sprints: configData.sprints,\n  \n  // Periods\n  periods: {\n    '7days': { label: 'Last 7 Days', startDate: configData.periods['7days'].start, endDate: configData.periods['7days'].end },\n    '15days': { label: 'Last 15 Days', startDate: configData.periods['15days'].start, endDate: configData.periods['15days'].end },\n    '30days': { label: 'Last 30 Days', startDate: configData.periods['30days'].start, endDate: configData.periods['30days'].end }\n  },\n  \n  // All boards data\n  boardsData,\n  \n  // Current board info (for backward compatibility)\n  boardInfo: {\n    id: defaultBoardId,\n    name: boardsData[defaultBoardId]?.boardName || 'Team Dashboard',\n    project: boardsData[defaultBoardId]?.project || 'PAI',\n    components: boardsData[defaultBoardId]?.components || []\n  },\n  \n  // Current board data (for backward compatibility)\n  teamSummary: boardsData[defaultBoardId]?.teamSummary || {},\n  members: boardsData[defaultBoardId]?.members || []\n};\n\nconsole.log(`‚úÖ Done! Processed ${availableBoards.length} boards, ${output.members.length} members`);\nreturn [{ json: output }];"
            },
            "id": "process-data",
            "name": "üìä Process Enhanced v2",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [900, 500]
        },
        {
            "parameters": {
                "jsCode": "const data = $input.first().json;\nconsole.log('=== Performance Dashboard v2.0 ===');\nconsole.log(`Version: ${data.version}`);\nconsole.log(`Boards: ${data.availableBoards.length}`);\nconsole.log(`Members: ${data.members.length}`);\nconsole.log(`Hours/Day: ${data.hoursPerDay}`);\nconsole.log(`7d Total: ${data.teamSummary['7days']?.total || 0}`);\nreturn [{ json: { performanceData: data, jsonString: JSON.stringify(data, null, 2) } }];"
            },
            "id": "format-output",
            "name": "üìù Format Output",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [1150, 500]
        },
        {
            "parameters": {
                "method": "PATCH",
                "url": "https://api.github.com/gists/c51929b485b22c47daf74474026fd444",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        { "name": "Authorization", "value": "Bearer YOUR_GITHUB_TOKEN_HERE" },
                        { "name": "Accept", "value": "application/vnd.github+json" },
                        { "name": "Content-Type", "value": "application/json" }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ { \"files\": { \"performance-data.json\": { \"content\": JSON.stringify($json.performanceData) } } } }}",
                "options": { "timeout": 60000 }
            },
            "id": "webhook-output",
            "name": "üåê Save to GitHub Gist",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [1400, 500],
            "disabled": false
        },
        {
            "parameters": {
                "jsCode": "console.log('‚úÖ Dashboard v2.0 data saved!');\nreturn [{ json: { status: 'success', version: '2.0', timestamp: new Date().toISOString() } }];"
            },
            "id": "success-log",
            "name": "‚úÖ Success",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [1650, 500]
        },
        {
            "parameters": {
                "content": "## üîß Configuration v2.0\n\n### Working Hours\n```\nHOURS_PER_DAY = 6\nHOURS_PER_WEEK = 30\n```\n\n### Bandwidth Calculations\n\n**Highest Utilization:**\n`hoursLogged / elapsedHours √ó 100`\n\n**Most Available (Task-based):**\n`openTasks / totalTasks √ó 100`\n= % of sprint work remaining\n\n**Individual Bandwidth:**\n`estimatedHours (Done tickets)`\nvs\n`loggedHours (Done tickets)`\n\n### Subtask Tracking\nWorklogs from subtasks are tracked by:\n- Author email\n- Timestamp within sprint\n- Attributed to the logger (not parent assignee)\n\n### Available Boards\n1. Bot Engine\n2. RE Platform 2.0\n3. Combined (Both)"
            },
            "id": "config-note",
            "name": "üîß Config Notes v2",
            "type": "n8n-nodes-base.stickyNote",
            "typeVersion": 1,
            "position": [100, 800]
        }
    ],
    "connections": {
        "Daily 9:30 PM IST": { "main": [[{ "node": "‚öôÔ∏è Setup Config v2", "type": "main", "index": 0 }]] },
        "Manual Trigger": { "main": [[{ "node": "‚öôÔ∏è Setup Config v2", "type": "main", "index": 0 }]] },
        "‚öôÔ∏è Setup Config v2": { "main": [[{ "node": "üì• JIRA - All Issues", "type": "main", "index": 0 }]] },
        "üì• JIRA - All Issues": { "main": [[{ "node": "üìä Process Enhanced v2", "type": "main", "index": 0 }]] },
        "üìä Process Enhanced v2": { "main": [[{ "node": "üìù Format Output", "type": "main", "index": 0 }]] },
        "üìù Format Output": { "main": [[{ "node": "üåê Save to GitHub Gist", "type": "main", "index": 0 }]] },
        "üåê Save to GitHub Gist": { "main": [[{ "node": "‚úÖ Success", "type": "main", "index": 0 }]] }
    },
    "active": false,
    "settings": { "executionOrder": "v1" },
    "versionId": "v2-enhanced-multiboard",
    "id": "performance-dashboard-workflow-v2",
    "meta": { "instanceId": "performance-bot" },
    "tags": ["enhanced", "multiboard", "v2"]
}
